<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <title>Weapon Viewer</title>
    <script type="module" src="https://ajax.googleapis.com/ajax/libs/model-viewer/3.3.0/model-viewer.min.js"></script>
    <style>
        html, body {
            margin: 0; padding: 0;
            width: 100%; height: 100%;
            background-color: transparent !important;
            overflow: hidden;
            /* 編集モード時の右クリックメニュー禁止 */
            user-select: none;
        }

        #wrapper {
            position: absolute;
            top: 0; left: 0;
            width: 100%; height: 100%;
            /* 初期位置を真ん中ではなく、扱いやすい位置に */
            transform-origin: center center;
            /* 編集時は即時反映させたいのでtransitionはJS側で制御 */
        }

        model-viewer {
            width: 100%; height: 100%;
            background-color: transparent;
            --poster-color: transparent;
        }
    </style>
</head>
<!-- 右クリックメニューを出さないようにする -->
<body oncontextmenu="return false;">

    <div id="wrapper">
        <model-viewer
            id="knife"
            src="./knife.glb" 
            disable-zoom
            disable-tap
            interaction-prompt="none"
            /* 影を消す設定 */
            shadow-intensity="0"
            autoplay
        ></model-viewer>
    </div>

    <script>
        const wrapper = document.getElementById('wrapper');
        const modelViewer = document.getElementById('knife');

        // === 状態管理変数 ===
        // ユーザーが決めた固定位置・角度・ズーム
        let config = {
            posX: 0,      // 画面上のX位置
            posY: 0,      // 画面上のY位置
            orbitX: -30,  // カメラの水平角度 (deg)
            orbitY: 80,   // カメラの垂直角度 (deg)
            distance: 2.5 // カメラの距離 (m)
        };

        // ゲーム側から送られてくる揺れデータ
        let sway = { x: 0, y: 0, rotX: 0, rotY: 0 };

        // 編集モードかどうか
        let isEditMode = false;
        
        // マウス操作用の一時変数
        let isDraggingLeft = false;
        let isDraggingRight = false;
        let lastMouseX = 0;
        let lastMouseY = 0;

        // 初期設定の適用
        updateCamera();
        updateTransform();

        // === Voxiomからのメッセージ受信 ===
        window.addEventListener('message', (event) => {
            const data = event.data;

            // モード切替
            if (data.type === 'set-mode') {
                isEditMode = data.enabled;
                document.body.style.cursor = isEditMode ? 'move' : 'default';
            }

            // 揺れデータの更新 (編集モード中は揺れを止めて調整しやすくする)
            if (data.type === 'update-transform') {
                if (!isEditMode) {
                    sway.x = data.x;
                    sway.y = data.y;
                    sway.rotX = data.rotateX;
                    sway.rotY = data.rotateY;
                } else {
                    // 編集モード中は揺れをリセット
                    sway = { x: 0, y: 0, rotX: 0, rotY: 0 };
                }
                updateTransform();
            }

            // アニメーション再生
            if (data.type === 'play-animation') {
                const animName = data.name;
                const foundAnim = modelViewer.availableAnimations.find(a => a.toLowerCase().includes(animName.toLowerCase()));
                if (foundAnim) {
                    modelViewer.animationName = foundAnim;
                    modelViewer.currentTime = 0;
                    modelViewer.play();
                }
            }
        });

        // === 編集操作 (マウスイベント) ===
        window.addEventListener('mousedown', (e) => {
            if (!isEditMode) return;
            lastMouseX = e.clientX;
            lastMouseY = e.clientY;
            
            if (e.button === 0) isDraggingLeft = true;  // 左クリック
            if (e.button === 2) isDraggingRight = true; // 右クリック
        });

        window.addEventListener('mouseup', () => {
            isDraggingLeft = false;
            isDraggingRight = false;
        });

        window.addEventListener('mousemove', (e) => {
            if (!isEditMode) return;
            
            const deltaX = e.clientX - lastMouseX;
            const deltaY = e.clientY - lastMouseY;
            lastMouseX = e.clientX;
            lastMouseY = e.clientY;

            // 左ドラッグ：位置調整 (Position)
            if (isDraggingLeft) {
                config.posX += deltaX;
                config.posY += deltaY;
                updateTransform();
            }

            // 右ドラッグ：向き調整 (Rotation / Camera Orbit)
            if (isDraggingRight) {
                config.orbitX -= deltaX * 0.5; // 感度調整
                config.orbitY -= deltaY * 0.5;
                // 角度制限 (上下の反転防止など)
                config.orbitY = Math.max(10, Math.min(170, config.orbitY)); 
                updateCamera();
            }
        });

        // ホイール：拡大縮小 (Zoom)
        window.addEventListener('wheel', (e) => {
            if (!isEditMode) return;
            // スクロール量に応じて距離を変更
            config.distance += e.deltaY * 0.005;
            config.distance = Math.max(0.5, Math.min(10, config.distance)); // 制限
            updateCamera();
        });

        // === 描画更新関数 ===

        function updateCamera() {
            // model-viewerのカメラ位置を更新
            modelViewer.cameraOrbit = `${config.orbitX}deg ${config.orbitY}deg ${config.distance}m`;
        }

        function updateTransform() {
            // CSS Transformで位置と揺れを適用
            // 「設定した固定位置(config)」に「ゲームの揺れ(sway)」を足す
            wrapper.style.transform = `
                translate3d(${config.posX + sway.x}px, ${config.posY + sway.y}px, 0)
                rotateY(${sway.rotY}deg)
                rotateX(${sway.rotX}deg)
            `;
        }
    </script>
</body>
</html>
